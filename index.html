<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Minha Engine</title>
	<style >
		canvas {
			position: absolute;
			top: 0px;
			bottom: 0px;
			left: 0px;
			right: 0px;
			margin: auto;
		}
	</style>
</head>
<body>
<script>
	// Variaveis do jogo
	var canvas, 
		contextoDaCanvas, // Canvas: usada para desenhar
		alturaDaCanvas, // Contexto: associado ao canvas
		larguraDaCanvas, // Altura e largura: usada para pegar o tamanho da janela do jogador
		framesDaCanvas = 0, // Frames: controlar a taxa em que roda o jogo
		maxPulosDoPersonagem = 3, // Limite de pulos do personagem
		velocidadeDoBloco = 6, // Velocidade do bloco no jogo
		estadoAtualDoJogo, // Carrega o estado atual do jogo

		// Objeto estados: um analogo a um ENUM
		estadoDoJogo = {
			jogar: 0,
			jogando: 1,
			perdeu: 2,
		},

	// Objeto chao
	chaoDoJogo = {
		y: 550, // Coordenada y
		alturaDoChao: 50,
		corDoChao: "#e8da78",
		// Metodo desenha o chao do jogo
		desenhaChao: function() {
			// Pinta o fundo do chao de amarelo
			contextoDaCanvas.fillStyle = this.corDoChao;
			// contexto.fillRect(coordenada x, coordenada y, largura, altura)
			contextoDaCanvas.fillRect(0, this.y, larguraDaCanvas, this.alturaDoChao);
		}
	},

	// Objeto personagem
	personagemDoJogo = {
		x: 50, // Coordenada x: o personagem fica a uma distancia de 50px da borda esquerda da canvas
		y: 0,
		alturaDoPersonagem: 50,
		larguraDoPersonagem: 50,
		corDoPersonagem: "#ff9239",
		gravidadeDoPersonagem: 1.6, // A gravidade e constante
		velocidadeDoPersonagem: 0,
		forcaDoPulo: 23.6, // Forca com que o personagem pula
		qdtPulosDoPersonagem: 0, // Conta quantos pulos o personagem deu
		scoreDoJogo: 0,
		// Metodo atualiza a posicao do personagem do jogo
		atualizaPersonagem: function() {
			this.velocidadeDoPersonagem += this.gravidadeDoPersonagem;
			this.y += this.velocidadeDoPersonagem;

			// Fixando o personagem no chao do jogo
			if (this.y > chaoDoJogo.y - this.alturaDoPersonagem && estadoAtualDoJogo != estadoDoJogo.perdeu) {
				this.y = chaoDoJogo.y - this.alturaDoPersonagem;
				// Quando o personagem cair no chao ele pode pular mais tres vezes
				this.qdtPulosDoPersonagem = 0;
				this.velocidadeDoPersonagem = 0;
			}
		},
		// Metodo faz pular o personagem do jogo
		pulaPersonagem: function() {
			// Personagem pular consecutivamente somente tres vezes
			if (this.qdtPulosDoPersonagem < maxPulosDoPersonagem) {
				this.velocidadeDoPersonagem = -this.forcaDoPulo;
				this.qdtPulosDoPersonagem++;
			}
		},

		resetPersonagem: function() {
			this.velocidadeDoPersonagem = 0;
			this.y = 0; // Posiciona o personagem no topo do jogo
			this.scoreDoJogo = 0; // Quando perder zera o score do jogo
		},
		// Metodo desenha os blocos do jogo
		desenhaPersonagem: function() {
			contextoDaCanvas.fillStyle = this.corDoPersonagem;
			contextoDaCanvas.fillRect(this.x, this.y, this.larguraDoPersonagem, this.alturaDoPersonagem);
		}
	},
	
	// Objeto Obstaculo
	obstaculosDoJogo = {
		blocosDoJogo: [], // Array de obstaculos do tipo bloco
		coresDoBloco: ["#ffbc1c", "#ff1c1c", "#ff85e1", "#52a7ff", "#78ff5d"], // Array de cores para os blocos
		tempoInsereBloco: 0,

		// Metodo insere um obstaculo no jogo
		insereObstaculo: function() {
			this.blocosDoJogo.push({
				x: larguraDaCanvas, // Posiciona o bloco no lado direito da canvas
				
				//larguraDoBloco: 30 + Math.floor(21 * Math.random()), Cria uma largura aleatoria para o bloco
				larguraDoBloco: 50, // Fixa a largura do bloco para 50 pixels
				alturaDoBloco: 30 + Math.floor(120 * Math.random()), // Cria uma altura aleatoria para o bloco
				corDoBloco: this.coresDoBloco[Math.floor(5 * Math.random())] // Escolhe uma cor aleatoria do array coresDoBloco para um bloco
			});

			this.tempoInsereBloco = 30 + Math.floor(20 * Math.random());
		},
		// Metodo atualiza o obstaculo do jogo
		atualizaObstaculo: function() {
			// Fazendo com que os blocos passem na tela infinitamente
			if (this.tempoInsereBloco == 0) {
				this.insereObstaculo();
			} else {
				this.tempoInsereBloco--;
			}

			// Rodar o array de blocos
			for (var i = 0, tam = this.blocosDoJogo.length; i < tam; i++) {
				var obstaculo = this.blocosDoJogo[i];
				// Decrementando o x de cada bloco
				obstaculo.x -= velocidadeDoBloco;

				if (personagemDoJogo.x < obstaculo.x + obstaculo.larguraDoBloco &&
					personagemDoJogo.x + personagemDoJogo.larguraDoPersonagem >= obstaculo.x &&
					personagemDoJogo.y + personagemDoJogo.alturaDoPersonagem >= chaoDoJogo.y - obstaculo.alturaDoBloco) {
					estadoAtualDoJogo = estadoDoJogo.perdeu;
				} else if (obstaculo.x == 0) {
					personagemDoJogo.scoreDoJogo++; // Incrementa o score do jogo
				} else if (obstaculo.x <= -obstaculo.larguraDoBloco) {
					this.blocosDoJogo.splice(i, 1); // Remover um obstaculo
					tam--;
					i--;
				}
			}
		},

		limpaObstaculos: function() {
			this.blocosDoJogo = []; // Limpa o array de blocos do jogo
		},
		
		// Metodo desenha o obstaculo do jogo
		desenhaObstaculo: function() {
			// Varre o array de blocos do jogo
			for (var i = 0, tam = this.blocosDoJogo.length; i < tam; i++) {
				var obstaculo = this.blocosDoJogo[i]; // A variavel obstaculo recebe um bloco
				contextoDaCanvas.fillStyle = obstaculo.corDoBloco; // Setando a cor do bloco
				contextoDaCanvas.fillRect(obstaculo.x, chaoDoJogo.y - obstaculo.alturaDoBloco, obstaculo.larguraDoBloco, obstaculo.alturaDoBloco); // Setando a posicao do bloco
			}
		}
	};

	// Funcao identifica se o jogador clicou
	function clique(event) {

		if (estadoAtualDoJogo == estadoDoJogo.jogando) {
			personagemDoJogo.pulaPersonagem(); // Se o estado atual do jogo for jogando o personagem pula
		} else if (estadoAtualDoJogo == estadoDoJogo.jogar) {
			estadoAtualDoJogo = estadoDoJogo.jogando; // Se o estado atual do jogo for jogar altera o estado atual para jogando
		} else if (estadoAtualDoJogo == estadoDoJogo.perdeu && personagemDoJogo.y >= 2 * alturaDaCanvas) {
			estadoAtualDoJogo = estadoDoJogo.jogar; // Se o estado atual do jogo for perdeu altera o estado atual para jogar
			obstaculosDoJogo.limpaObstaculos(); // Se o estado atual for perdeu limpa os blocos da tela
			personagemDoJogo.resetPersonagem();
		}
	}	 

	// Funcao principal
	function main() {
		//Pegar o tamanho da janela do jogador
		alturaDaCanvas = window.innerHeight;
		larguraDaCanvas = window.innerWidth;

		// Verifica se a janela do jogador e maior ou igual a 500 pixel
		if (larguraDaCanvas >= 500) {
			larguraDaCanvas = 600;
			alturaDaCanvas  = 600;
		}

		// Criando no script um elemento do tipo canvas
		canvas = document.createElement("canvas");
		// Elementos padrao da canvas
		canvas.width = larguraDaCanvas;
		canvas.height = alturaDaCanvas;
		canvas.style.border = "1px solid #000";

		// Definindo o contexto para desenhar elementos em 2D
		contextoDaCanvas = canvas.getContext("2d");

		// Adicionando a canvas no HTML
		document.body.appendChild(canvas);

		// Verificar se o jogador clicou
		document.addEventListener("mousedown", clique); 

		// Setando o estado do jogo
		estadoAtualDoJogo = estadoDoJogo.jogar;

		// A funcao roda ficara em loop 	
		roda();
	}

	// Funcao atualiza e redesenha a canvas
	function roda() {
		atualiza();
		desenha();

		// Chama a funcao roda contantemente, coloca a funcao roda em loop infinito
		window.requestAnimationFrame(roda);
	}

	// Funcao atualiza o status do personagem, dos blocos
	function atualiza() {
		framesDaCanvas++;
		personagemDoJogo.atualizaPersonagem();
		
		if (estadoAtualDoJogo == estadoDoJogo.jogando) {
			obstaculosDoJogo.atualizaObstaculo(); // Se o estado atual for jogando os blocos ficarao passando na tela
		}
	}
	
	// Funcao desenha o personagem, os blocos, o chao
	function desenha() {
		// Pinta o fundo da canvas na cor azul
		contextoDaCanvas.fillStyle = "#80daff";
		// contexto.fillRect(coordenada x, coordenada y, largura, altura)
		contextoDaCanvas.fillRect(0, 0, larguraDaCanvas, alturaDaCanvas);

		// Desenhando o score do jogo
		contextoDaCanvas.fillStyle = "#ffffff"; // Cor branca
		contextoDaCanvas.font = "50px Arial"; // Tamanho de 50 pixels e arial
		contextoDaCanvas.fillText(personagemDoJogo.scoreDoJogo, 30, 68);

		if (estadoAtualDoJogo == estadoDoJogo.jogar) {
			contextoDaCanvas.fillStyle = "green";
			contextoDaCanvas.fillRect(larguraDaCanvas / 2 - 50, alturaDaCanvas / 2 - 50, 100, 100);
		} else if (estadoAtualDoJogo == estadoDoJogo.perdeu) {
			contextoDaCanvas.fillStyle = "red";
			contextoDaCanvas.fillRect(larguraDaCanvas / 2 - 50, alturaDaCanvas / 2 - 50, 100, 100);
			contextoDaCanvas.save(); // Salva o contexto
			contextoDaCanvas.translate(larguraDaCanvas / 2, alturaDaCanvas / 2); // Tranlada para o meio da canvas
			contextoDaCanvas.fillStyle = "#ffffff";
			
			if (personagemDoJogo.scoreDoJogo < 10) {
				contextoDaCanvas.fillText(personagemDoJogo.scoreDoJogo, -13, 19); // Centraliza o score com valor menor que 10
			} else if (personagemDoJogo.scoreDoJogo >= 10 && personagemDoJogo.scoreDoJogo < 100) {
				contextoDaCanvas.fillText(personagemDoJogo.scoreDoJogo, -26, 19); // Centraliza o score com valor maior ou igual a 10 e menor que 100
			} else if (personagemDoJogo.scoreDoJogo >= 100 && personagemDoJogo.scoreDoJogo < 1000) {
				contextoDaCanvas.fillText(personagemDoJogo.scoreDoJogo, -39, 19); // Centraliza o score com valor maior ou igual a 100 e menor que 1000
			} else {
				contextoDaCanvas.fillText(personagemDoJogo.scoreDoJogo, -59, 19); // Centraliza o score com valor maior ou igual a 1000
			}

			contextoDaCanvas.restore();
		} else if (estadoAtualDoJogo == estadoDoJogo.jogando) {
			// Desenha o obstaculo do jogo
			obstaculosDoJogo.desenhaObstaculo();
		}
		
		// Desenha o chao do jogo
		chaoDoJogo.desenhaChao();
		// Desenha o bloco do jogo
		personagemDoJogo.desenhaPersonagem();
	}
	
	// Inicializa o jogo
	main();
</script>
</body>
</html>